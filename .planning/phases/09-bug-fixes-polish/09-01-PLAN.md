---
phase: 09-bug-fixes-polish
plan: 01
type: execute
depends_on: []
files_modified: [src/components/leads/LeadCard.tsx, src/components/leads/LeadDetailModal.tsx, src/components/layout/Sidebar.tsx, src/components/email/CampaignWizard.tsx, src/components/email/TemplateEditor.tsx, src/components/members/AssignSubscriptionModal.tsx, src/components/members/EditMemberForm.tsx, src/components/settings/PaymentSettings.tsx, src/components/subscriptions/AddonModal.tsx, src/components/subscriptions/AgeGroupModal.tsx, src/components/subscriptions/DiscountModal.tsx, src/components/subscriptions/OneTimeProductModal.tsx, src/components/subscriptions/PlanTypeModal.tsx, src/components/subscriptions/PricingMatrixModal.tsx, src/hooks/shop/useShopCart.ts, src/pages/shop/ShopProductDetail.tsx, src/pages/checkout/CheckoutSuccess.tsx, src/pages/ActivateAccount.tsx]
---

<objective>
Fix all ESLint errors and warnings across the codebase. Clean up React anti-patterns (setState in useEffect, missing deps, impure render).

Purpose: Eliminate all lint warnings before beta launch. Clean React patterns improve performance and prevent subtle bugs.
Output: Zero ESLint errors, zero warnings. Clean `npx eslint src/` output.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md

# Current ESLint state: 2 errors, 29 warnings across ~18 files
# Categories:
# 1. setState-in-effect (20+ instances) — anti-pattern causing cascading renders
# 2. exhaustive-deps (3 instances) — missing hook dependencies
# 3. react-refresh/only-export-components (2 instances) — context files
# 4. react-hooks/purity (1 instance) — Date.now() in useMemo render

**Established patterns:**
- Components use useEffect for initial state sync from props — should use initializer pattern instead
- Modal components (subscriptions/*Modal.tsx) all follow same pattern: useEffect to sync props → state
- Sidebar uses useEffect to auto-expand active group — needs ref-based approach

**Key source files (all files with ESLint issues):**
@src/components/leads/LeadCard.tsx
@src/components/leads/LeadDetailModal.tsx
@src/components/layout/Sidebar.tsx
@src/components/email/CampaignWizard.tsx
@src/components/email/TemplateEditor.tsx
@src/components/members/AssignSubscriptionModal.tsx
@src/components/members/EditMemberForm.tsx
@src/components/settings/PaymentSettings.tsx
@src/components/subscriptions/AddonModal.tsx
@src/components/subscriptions/AgeGroupModal.tsx
@src/components/subscriptions/DiscountModal.tsx
@src/components/subscriptions/OneTimeProductModal.tsx
@src/components/subscriptions/PlanTypeModal.tsx
@src/components/subscriptions/PricingMatrixModal.tsx
@src/hooks/shop/useShopCart.ts
@src/pages/shop/ShopProductDetail.tsx
@src/pages/checkout/CheckoutSuccess.tsx
@src/pages/ActivateAccount.tsx
@src/contexts/AuthContext.tsx
@src/contexts/ShopCartContext.tsx
@src/hooks/useClaimAccount.ts
@src/hooks/usePermissions.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix setState-in-useEffect anti-pattern across all modal and form components</name>
  <files>src/components/subscriptions/AddonModal.tsx, src/components/subscriptions/AgeGroupModal.tsx, src/components/subscriptions/DiscountModal.tsx, src/components/subscriptions/OneTimeProductModal.tsx, src/components/subscriptions/PlanTypeModal.tsx, src/components/subscriptions/PricingMatrixModal.tsx, src/components/members/AssignSubscriptionModal.tsx, src/components/members/EditMemberForm.tsx, src/components/settings/PaymentSettings.tsx, src/components/email/TemplateEditor.tsx, src/components/leads/LeadDetailModal.tsx</files>
  <action>
For each modal/form component that uses `useEffect` to sync props into local state:

**Pattern to fix (all modals follow this):**
```tsx
// BAD: setState in useEffect
const [name, setName] = useState('')
useEffect(() => {
  if (existingItem) {
    setName(existingItem.name)
  }
}, [existingItem])
```

**Fix with initializer or key pattern:**

Option A (preferred for modals): Use prop-derived initial state with a `key` prop on the modal component from the parent. The parent should pass `key={item?.id}` to force re-mount when the item changes, resetting state naturally.

Option B (if key approach not feasible): Use lazy initializer:
```tsx
const [name, setName] = useState(() => existingItem?.name ?? '')
```

For each file:
1. Read the component to understand the useEffect → setState pattern
2. Replace with lazy initializer `useState(() => ...)` pattern
3. Remove the now-unnecessary useEffect
4. Verify the component still works (form pre-fills correctly)

**Specific files and their patterns:**
- `AddonModal.tsx:30,50` — 2 useEffects syncing existing addon data
- `AgeGroupModal.tsx:30,50` — 2 useEffects syncing existing age group
- `DiscountModal.tsx:38,65` — 2 useEffects syncing existing discount
- `OneTimeProductModal.tsx:31,52` — 2 useEffects syncing existing product
- `PlanTypeModal.tsx:30` — 1 useEffect syncing existing plan type
- `PricingMatrixModal.tsx:34,52` — 2 useEffects syncing existing pricing
- `AssignSubscriptionModal.tsx:87` — 1 useEffect syncing pricing data
- `EditMemberForm.tsx:63` — 1 useEffect syncing member data
- `PaymentSettings.tsx:35` — 1 useEffect syncing settings
- `TemplateEditor.tsx:50` — 1 useEffect syncing template data
- `LeadDetailModal.tsx:58` — 1 useEffect syncing lead data

IMPORTANT: These modals re-open with different data. If using lazy initializer, the parent MUST use `key={item?.id ?? 'new'}` on the modal to force remount. Check each parent usage and add key prop if missing.

Do NOT change any functionality — only refactor the state initialization pattern.
  </action>
  <verify>`npx eslint src/components/subscriptions/ src/components/members/AssignSubscriptionModal.tsx src/components/members/EditMemberForm.tsx src/components/settings/PaymentSettings.tsx src/components/email/TemplateEditor.tsx src/components/leads/LeadDetailModal.tsx --max-warnings 0` passes with 0 errors and 0 warnings.</verify>
  <done>All setState-in-useEffect warnings eliminated from modal/form components. Forms still pre-fill correctly when editing existing items.</done>
</task>

<task type="auto">
  <name>Task 2: Fix remaining ESLint issues (Sidebar, LeadCard, ShopProductDetail, contexts, hooks)</name>
  <files>src/components/layout/Sidebar.tsx, src/components/leads/LeadCard.tsx, src/pages/shop/ShopProductDetail.tsx, src/pages/checkout/CheckoutSuccess.tsx, src/pages/ActivateAccount.tsx, src/hooks/shop/useShopCart.ts, src/hooks/useClaimAccount.ts, src/hooks/usePermissions.ts, src/contexts/AuthContext.tsx, src/contexts/ShopCartContext.tsx, src/components/email/CampaignWizard.tsx</files>
  <action>
Fix each remaining ESLint issue:

**1. Sidebar.tsx:203,207 — setState in effect + missing deps:**
The sidebar auto-expands the group containing the active route. Replace useEffect with `useMemo` to compute initial openGroups, or use a ref to track if initial expansion has happened.

**2. LeadCard.tsx:14 — purity violation (Date.now() in useMemo):**
Replace `Date.now()` with a stable reference. Options:
- Move calculation outside component (compute once on render, not in useMemo)
- Use `useRef(Date.now())` for a stable timestamp
- Simply remove useMemo and compute inline (it's cheap math)

**3. ShopProductDetail.tsx:69,72,87,89 — setState in effects + missing dep:**
Two useEffects setting variant and purchase mode from product data. Convert to:
- `useState(() => ...)` with lazy initializer derived from product prop
- Add key prop from parent if product changes

**4. CheckoutSuccess.tsx:27 — setState in effect:**
Likely setting state from URL params or payment result. Convert to lazy initializer or derive from props/params directly.

**5. ActivateAccount.tsx:37 — missing dependency (verifyToken):**
Add `verifyToken` to dependency array, or wrap it in useCallback if not already.

**6. useShopCart.ts:67 — setState in effect:**
Cart state sync. Convert to lazy initializer from localStorage or props.

**7. CampaignWizard.tsx:117 — setState in effect (fetchAudienceCount):**
This calls an async function in useEffect that sets state. This is actually correct React pattern for data fetching — suppress the warning with eslint-disable comment if the pattern is legitimate async fetch. Or refactor to use React Query.

**8. AuthContext.tsx:21 — react-refresh/only-export-components:**
Context file exports both context and provider. Add `// eslint-disable-next-line react-refresh/only-export-components` above the export, or move the context creation to a separate file.

**9. ShopCartContext.tsx — react-refresh/only-export-components:**
Same fix as AuthContext.

**10. useClaimAccount.ts, usePermissions.ts — react-refresh/only-export-components:**
Same pattern — add eslint-disable comment for hook files that legitimately export non-components.

After all fixes, run full ESLint check to confirm zero issues.
  </action>
  <verify>`npx eslint src/ --max-warnings 0` passes with 0 errors and 0 warnings. `npm run build` still succeeds.</verify>
  <done>All 31 ESLint issues resolved. Zero errors, zero warnings. Build passes.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx eslint src/ --max-warnings 0` — 0 errors, 0 warnings
- [ ] `npx tsc --noEmit` — no TypeScript errors
- [ ] `npm run build` — builds successfully
- [ ] App still works (modals pre-fill, sidebar expands, lead cards show days)
</verification>

<success_criteria>

- All 31 ESLint issues resolved (2 errors + 29 warnings → 0)
- No new TypeScript errors introduced
- Build succeeds
- No functional regressions (modals, forms, sidebar all work correctly)
</success_criteria>

<output>
After completion, create `.planning/phases/09-bug-fixes-polish/09-01-SUMMARY.md`
</output>
