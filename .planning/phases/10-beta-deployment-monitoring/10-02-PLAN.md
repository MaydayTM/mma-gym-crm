---
phase: 10-beta-deployment-monitoring
plan: 02
type: execute
depends_on: ["10-01"]
files_modified: [src/components/feedback/BetaFeedbackWidget.tsx, src/hooks/useFeedback.ts, src/App.tsx]
---

<objective>
Create an in-app beta feedback mechanism, set up external uptime monitoring, and prepare for first beta tester invitations.

Purpose: Give beta testers a way to report issues directly from the app, ensure the app is monitored for downtime, and validate the invite flow works end-to-end.
Output: Working feedback widget, active uptime monitoring, and verified beta invite capability.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-beta-deployment-monitoring/10-01-SUMMARY.md

# Key files:
@src/App.tsx
@src/hooks/useAuth.ts
@src/components/settings/OnboardingSettings.tsx

**Tech stack available:** Supabase (PostgreSQL + Edge Functions + Auth), Resend email, Vercel hosting, Sentry error tracking (from Plan 10-01)
**Established patterns:**
- TanStack Query for data mutations
- Permission-based UI gating (usePermissions)
- Inline Dutch language for all user-facing text
- Claim account flow already built and tested (Phase 6)

**Constraining decisions:**
- Phase 6: Claim flow uses send-claim-email Edge Function with bulk invite capability
- Phase 1: Account claim tokens stored as SHA256 hash, 48h expiry
- Supabase RLS: `USING(true)` + app-layer role checks pattern
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create beta feedback table and in-app feedback widget</name>
  <files>src/components/feedback/BetaFeedbackWidget.tsx, src/hooks/useFeedback.ts, src/App.tsx</files>
  <action>
1. Create a new Supabase migration for the beta_feedback table:
   ```sql
   CREATE TABLE beta_feedback (
     id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
     member_id UUID REFERENCES members(id) ON DELETE SET NULL,
     category VARCHAR(50) NOT NULL DEFAULT 'general',  -- 'bug', 'feature', 'general', 'ux'
     message TEXT NOT NULL,
     page_url TEXT,
     user_agent TEXT,
     created_at TIMESTAMPTZ DEFAULT NOW()
   );

   -- RLS: authenticated users can insert their own feedback, admins can read all
   ALTER TABLE beta_feedback ENABLE ROW LEVEL SECURITY;

   CREATE POLICY "Users can submit feedback" ON beta_feedback
     FOR INSERT WITH CHECK (auth.uid() IS NOT NULL);

   CREATE POLICY "Admins can read all feedback" ON beta_feedback
     FOR SELECT USING (true);
   ```
   Push with `npx supabase db push`.

2. Regenerate types: `npx supabase gen types typescript --linked > src/types/database.types.ts`

3. Create `src/hooks/useFeedback.ts`:
   - `useSubmitFeedback()` mutation that inserts into beta_feedback with member_id from useAuth, current page URL from window.location.pathname, and navigator.userAgent
   - Return mutation with onSuccess that shows a success state

4. Create `src/components/feedback/BetaFeedbackWidget.tsx`:
   - Floating button in bottom-right corner (fixed position) with a message/chat icon from lucide-react
   - On click, opens a small modal/popover with:
     - Category select: Bug, Feature Request, Algemeen, UX
     - Textarea for message (required, min 10 chars)
     - Submit button
   - On successful submit: show "Bedankt voor je feedback!" message, auto-close after 2 seconds
   - Style: consistent with app design (Tailwind, white card, shadow-lg, rounded)
   - Only show for authenticated users

5. Add `<BetaFeedbackWidget />` in `src/App.tsx` inside the authenticated layout (after the main content, outside Routes so it appears on all pages).

**AVOID:** Do NOT create a separate page for feedback — the floating widget is more accessible. Do NOT use a third-party feedback tool — Supabase table is simpler and keeps data in-house. Do NOT make the widget intrusive — it should be a small floating button that expands on click.
  </action>
  <verify>npm run build succeeds. Check that BetaFeedbackWidget is imported in App.tsx. Verify the migration was pushed: `npx supabase db push --dry-run` shows no pending changes.</verify>
  <done>beta_feedback table exists with RLS, useFeedback hook works, floating feedback widget renders on all authenticated pages, form submits to Supabase.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Sentry error tracking (from Plan 10-01) and beta feedback widget. Now need to set up external monitoring and verify everything works.</what-built>
  <how-to-verify>
    1. **Sentry Setup** (if not done yet):
       - Go to https://sentry.io → Create account/project for "rcn-crm" (React platform)
       - Copy the DSN and add to Vercel env vars: `VITE_SENTRY_DSN=https://xxx@xxx.ingest.sentry.io/xxx`
       - Create auth token at https://sentry.io/settings/auth-tokens/ → add to Vercel env as `SENTRY_AUTH_TOKEN`
       - Set `SENTRY_ORG` and `SENTRY_PROJECT` in Vercel env vars
       - Deploy: `vercel --prod`
       - Visit the app, open console, run: `throw new Error('Sentry test')` — verify it appears in Sentry dashboard

    2. **UptimeRobot Setup**:
       - Go to https://uptimerobot.com → Create free account
       - Add monitor: HTTP(s), URL: your production URL (e.g., https://rcn-crm.vercel.app)
       - Set check interval: 5 minutes
       - Add alert contact: your email
       - Optionally add a second monitor for the Supabase Edge Functions health endpoint

    3. **Feedback Widget Test**:
       - Visit the app (logged in)
       - Look for floating feedback button in bottom-right
       - Click it, select "Bug" category, type a test message
       - Submit and verify "Bedankt" confirmation appears
       - Check Supabase dashboard → beta_feedback table has the entry

    4. Confirm all three systems working: Sentry captures errors, UptimeRobot is monitoring, feedback widget submits
  </how-to-verify>
  <resume-signal>Type "approved" to continue, or describe issues to fix</resume-signal>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete beta infrastructure: error tracking, monitoring, feedback. Ready to invite first beta testers.</what-built>
  <how-to-verify>
    1. **Prepare beta invite list:**
       - Go to Settings → Onboarding in the CRM
       - Identify 3-5 trusted members to invite as first beta testers
       - These members should already exist in the members table (imported from ClubPlanner)

    2. **Send first invites:**
       - Use the bulk invite feature in Onboarding Settings
       - Select the 3-5 beta testers
       - Send claim account emails
       - Verify emails arrive in their inboxes (check with at least 1 tester)

    3. **Verify claim flow:**
       - Have at least 1 beta tester click the claim link
       - Verify they can set their password and log in
       - Verify they see the feedback widget
       - Ask them to submit a test feedback entry

    4. Confirm: At least 1 beta tester successfully claimed their account and can use the CRM
  </how-to-verify>
  <resume-signal>Type "approved" when at least 1 beta tester has successfully claimed and logged in, or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `npm run build` succeeds without errors
- [ ] beta_feedback table exists in Supabase with correct RLS policies
- [ ] Feedback widget visible on all authenticated pages
- [ ] Sentry dashboard receiving errors from production (test error sent)
- [ ] UptimeRobot monitoring the production URL
- [ ] At least 1 beta tester successfully claimed account
- [ ] Phase 10 complete — v2.0 Beta Launch milestone done
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No errors or warnings introduced
- Beta infrastructure operational: Sentry + UptimeRobot + feedback widget
- At least 1 beta tester successfully onboarded
- Phase 10 complete — entire v2.0 Beta Launch milestone finished
</success_criteria>

<output>
After completion, create `.planning/phases/10-beta-deployment-monitoring/10-02-SUMMARY.md`
</output>
