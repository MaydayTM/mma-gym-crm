---
phase: 04-roles-permissions-audit
plan: 01
type: execute
depends_on: []
files_modified: [src/components/auth/RoleGuard.tsx, src/App.tsx, src/components/auth/index.ts]
---

<objective>
Create a reusable RoleGuard component and apply route-level access control to all protected pages.

Purpose: Currently all authenticated users can access all pages (except Team via sidebar hiding). A fighter can navigate directly to /team, /reports, /settings etc. This plan adds proper route-level enforcement so unauthorized roles see an access-denied message or get redirected.
Output: RoleGuard component + all routes in App.tsx wrapped with appropriate role requirements.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/hooks/usePermissions.ts
@src/App.tsx
@src/components/auth/ProtectedRoute.tsx
@src/components/layout/Sidebar.tsx

**Key decisions:**
- RLS uses `USING(true)` + app-layer role checks (avoid querying members table in policies - causes recursion)
- Role hierarchy: admin(100) > medewerker(80) > coordinator(60) > coach(40) > fighter(20) > fan(10)
- STAFF_ROLES: admin, medewerker, coordinator
- TEAM_ROLES: admin, medewerker, coordinator, coach

**Established patterns:**
- usePermissions hook exposes: isAdmin, isStaff, isTeamMember, canEditMembers, canManageLeads, etc.
- ProtectedRoute already handles auth check + redirect to /login
- Sidebar uses `adminOnly` flag and `member?.role === 'admin'` for filtering
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create RoleGuard component</name>
  <files>src/components/auth/RoleGuard.tsx, src/components/auth/index.ts</files>
  <action>
Create a RoleGuard component that wraps page content and checks role-based access using the existing usePermissions hook.

Props interface:
- `requiredRole?: Role` - minimum role level required (uses hasMinimumRole)
- `allowedRoles?: Role[]` - explicit list of allowed roles
- `permission?: keyof Permissions` - check a specific boolean permission (e.g., 'canManageLeads')
- `children: React.ReactNode`
- `fallback?: React.ReactNode` - optional custom fallback (defaults to access denied message)

Behavior:
- If user's role doesn't meet requirements, show a simple "Geen toegang" (No access) message with a back button
- Use Tailwind styling consistent with the app's dark theme (bg-zinc-900, text-white patterns)
- Import and use usePermissions hook for all checks
- Do NOT redirect - show inline access denied so users understand why they can't access the page

Export RoleGuard from the auth barrel file (src/components/auth/index.ts).

Avoid creating a new context or provider - leverage existing usePermissions hook directly.
  </action>
  <verify>TypeScript compiles: npx tsc --noEmit (no new errors related to RoleGuard)</verify>
  <done>RoleGuard component exists, exported from auth barrel, accepts role/permission props, shows access denied for unauthorized users</done>
</task>

<task type="auto">
  <name>Task 2: Apply RoleGuard to protected routes in App.tsx</name>
  <files>src/App.tsx</files>
  <action>
Wrap route elements in App.tsx with RoleGuard based on this access matrix:

**No guard needed (all authenticated users):**
- `/` (Dashboard) - everyone sees it
- `/kitana` - accessible to all
- `/members` - list view is okay for all (detail actions protected in Plan 04-02)
- `/members/:id` - detail view okay for all (actions protected in Plan 04-02)
- `/schedule` - view accessible to team + fighters (permission: canViewSchedule)
- `/reservations` - accessible to all authenticated
- `/gymscreen` - accessible to all authenticated (display screen)

**Staff only (admin, medewerker, coordinator):**
- `/leads` - permission: canManageLeads
- `/subscriptions` - permission: canEditMembers (staff manages subscriptions)
- `/subscriptions/manage` - permission: canEditMembers
- `/checkin` - permission: canCheckInMembers
- `/reports` - permission: canManageFinances (reports contain financial data)
- `/settings` - permission: isStaff (settings are admin/staff territory)

**Admin only:**
- `/team` - permission: isAdmin
- `/door-test` - permission: isAdmin (hardware testing)

**Module-based (keep existing):**
- `/shop` - already has module access check
- `/email` - already has module access check

Apply RoleGuard by wrapping the element prop, e.g.:
`<Route path="leads" element={<RoleGuard permission="canManageLeads"><Leads /></RoleGuard>} />`

Apply to BOTH route groups (the `/` group and the `/app.html` group).

Avoid breaking existing ProtectedRoute wrapping - RoleGuard goes inside ProtectedRoute, around individual page elements.
  </action>
  <verify>npm run build succeeds without errors. Navigate to /leads as a fighter role should show access denied.</verify>
  <done>All routes wrapped with appropriate RoleGuard. Staff-only pages blocked for fighters/fans. Admin-only pages blocked for non-admins. Build passes.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] RoleGuard component properly exported
- [ ] Routes have correct role guards applied
- [ ] Both route groups (/ and /app.html) have matching guards
</verification>

<success_criteria>

- RoleGuard component created and exported
- All protected routes have appropriate role guards
- Build passes without errors
- No TypeScript errors introduced
</success_criteria>

<output>
After completion, create `.planning/phases/04-roles-permissions-audit/04-01-SUMMARY.md`
</output>
