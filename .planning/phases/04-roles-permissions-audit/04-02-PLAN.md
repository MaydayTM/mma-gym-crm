---
phase: 04-roles-permissions-audit
plan: 02
type: execute
depends_on: ["04-01"]
files_modified: [src/pages/MemberDetail.tsx, src/pages/Members.tsx, src/components/members/EditMemberForm.tsx]
---

<objective>
Add permission checks to member management pages - MemberDetail and Members list.

Purpose: Currently any authenticated user can see edit/delete buttons on MemberDetail and potentially modify any member's data. This plan enforces that only staff can edit members, only admins can delete, and fighters can only edit their own profile.
Output: MemberDetail and Members pages with proper permission-gated action buttons.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-roles-permissions-audit/04-01-SUMMARY.md

@src/pages/MemberDetail.tsx
@src/pages/Members.tsx
@src/components/members/EditMemberForm.tsx
@src/hooks/usePermissions.ts
@src/contexts/AuthContext.tsx

**Key decisions:**
- RLS uses `USING(true)` + app-layer role checks
- usePermissions exposes: canEditMembers (staff), canModifyMember(role), isAdmin, canManageRoles
- Database trigger `prevent_role_escalation` prevents non-admins from changing roles (migration 056)
- EditMemberForm already uses canManageRoles and canAssignRole for role field visibility

**Access rules for member management:**
- View member detail: All authenticated users (read access is broad)
- Edit member: Staff can edit any member. Fighters can edit ONLY their own profile.
- Delete member: Admin only
- Assign subscription: Staff only
- Check-in member: Staff only
- View check-in history: All authenticated (read)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add permission checks to MemberDetail page</name>
  <files>src/pages/MemberDetail.tsx</files>
  <action>
Import and use usePermissions hook in MemberDetail page. Also import useAuth to get current user's member ID for "own profile" check.

Apply these permission gates:

1. **Edit button**: Show only if `canEditMembers` OR if the member being viewed is the current user (fighter editing own profile). Use: `const canEdit = permissions.canEditMembers || member.id === currentMember?.id`

2. **Delete button**: Show only if `permissions.isAdmin`. Wrap the delete button and its modal trigger with `isAdmin` check.

3. **Assign Subscription button** (if exists): Show only if `permissions.canEditMembers` (staff only).

4. **Manual check-in button** (if exists): Show only if `permissions.canCheckInMembers` (staff only).

5. **"Own profile" edit**: When a fighter edits their own profile, the EditMemberForm already restricts role changes via canManageRoles. No additional work needed there.

Do NOT hide the member detail view itself - all authenticated users can view member profiles (read access is intentional for team coordination).

Keep the existing UI structure. Only add conditional rendering around action buttons.
  </action>
  <verify>npm run build succeeds. Review that edit button logic includes own-profile check.</verify>
  <done>Edit button: visible for staff OR own profile. Delete button: admin only. Subscription assign: staff only. Check-in: staff only. Build passes.</done>
</task>

<task type="auto">
  <name>Task 2: Add permission checks to Members list page</name>
  <files>src/pages/Members.tsx</files>
  <action>
Import and use usePermissions in the Members list page.

Check for these action elements and gate them:
1. **"Add Member" / "Nieuw lid" button**: Show only if `canEditMembers` (staff only - fighters shouldn't create members).
2. **Bulk actions** (if any exist, like bulk delete or bulk status change): Gate with `isAdmin` or `canEditMembers` as appropriate.
3. **CSV import button** (if visible): Gate with `isAdmin` (data import is admin territory).
4. **Row click / navigation to member detail**: Keep accessible for all (viewing is allowed).
5. **Any inline edit or delete actions on table rows**: Gate with appropriate permissions.

Review the Members page to understand what actions exist, then apply the minimal permission checks needed. Don't over-engineer - if the only action is "Add Member" button, just gate that.
  </action>
  <verify>npm run build succeeds. Members page loads for all roles but action buttons are hidden for non-staff.</verify>
  <done>Members list page actions gated by permissions. Staff sees full actions, fighters/fans see read-only list. Build passes.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] MemberDetail: edit visible for staff + own profile, delete for admin only
- [ ] Members: add/import buttons visible for staff/admin only
- [ ] No TypeScript errors introduced
</verification>

<success_criteria>

- All member management actions properly gated
- Fighters can still edit their own profile
- Fighters cannot edit/delete other members
- Admin-only actions (delete) properly restricted
- Build passes without errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-roles-permissions-audit/04-02-SUMMARY.md`
</output>
